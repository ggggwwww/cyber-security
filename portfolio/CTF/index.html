<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>CTF Pyramid Walkthrough</title>
    <link rel="stylesheet" href="index.css" />
  </head>

  <body>
    <div class="tab-shell">
      <button class="tab-button is-active" data-target="ctf-page">
        CTF Walkthrough
      </button>
      <button class="tab-button" data-target="making-page">제작 과정</button>
      <button class="tab-button" data-target="end-notes">후기</button>
    </div>
    <main class="making-page">
      <header class="ctf-header"></header>
      <section class="ctf-section">
        <h2 class="heading-sub">Pyramid CTF 제작 개요</h2>
        <p class="para">프로젝트 배경:</p>
        <p class="para">
          CTF를 처음 접하는 사람들도 자연스럽게 웹 취약점부터 시스템 권한
          상승까지 단계적으로 경험할 수 있는 시나리오를 만들고 싶었습니다.
          단순히 취약점 나열이 아니라, 좀 더 재미있는 방식으로 접근할 수 있게
          단계별 흐름을 배치하고 침투 과정을 압축해 표현하되 각 단계에서 배우는
          것이 명확해야 한다고 생각했습니다.
        </p>
        <p class="para">컨셉 선정:</p>
        <p class="para">
          '이집트'와 '피라미드'를 키워드로 잡아, 4단계 문제가 마치 피라미드
          상층부로 올라가듯 난이도를 높이 고 최종적으로 ' 파라오의 보물(Final
          Flag)'에 도달하는 스토리라인을 구성했습니다
        </p>
        <p class="para">4단계 문제 흐름도</p>
        <table class="vuln-table">
          <thead>
            <tr>
              <th scope="col">단계</th>
              <th scope="col">취약점 유형</th>
              <th scope="col">설명</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>1단계</td>
              <td>SQL Injection (웹)</td>
              <td>데이터베이스에 직접 접근하여 사용자 인증 우회</td>
            </tr>
            <tr>
              <td>2단계</td>
              <td>Sensitive Data Exposure, Steganography (웹)</td>
              <td>
                응답 헤더·주석에 숨겨진 정보 발견, 이미지에 인코딩된 데이터 추출
              </td>
            </tr>
            <tr>
              <td>3단계</td>
              <td>Broken Access Control, Directory Listing (웹)</td>
              <td>
                부적절한 권한 검사로 인한 파일 접근, 디렉토리 탐색을 통한 정보
                수집
              </td>
            </tr>
            <tr>
              <td>4단계</td>
              <td>Buffer Overflow, SetUID 권한 상승 (시스템)</td>
              <td>
                스택 오버플로우로 EIP 제어 후 권한 상승 바이너리 실행, 최종 Flag
                획득
              </td>
            </tr>
          </tbody>
        </table>
        <p class="para">각 단계를 순서대로 풀어야만 다음 단계의 힌트나 접근 경로가 열리는 흐름을 설계했습니다.</p>
        
        <figure class="fig">
          <img src="images/making/머신 구조.png" alt="머신 구조" />
          <figcaption class="fig-caption">시스템 구조 구성도</figcaption>
          <p class="para">
            제가 담당한 파트인 시스템 부문의 구조에서는 매 1분마다 작동하는
            crontab 작업이 있습니다. 이 작업은 /home/pyramid 디렉터리 내의 특정
            스크립트를 실행하여, CTF 문제 풀이에 필요한 힌트와 파일들을
            주기적으로 갱신합니다. 이를 통해 참가자들은 지속적으로 새로운 정보를
            얻으며 도전 과제를 해결할 수 있습니다.
          </p>
          <p class="para">
            일부러 일부 폴더와 파일에 필요 이상의 권한을 부여하여, 참가자들이
            권한 상승(Privilege Escalation) 기법을 연습할 수 있도록
            설계하였습니다. 이를 통해 참가자들은 실제 환경에서 발생할 수 있는
            보안 취약점을 이해하고 대응하는 능력을 키울 수 있습니다.
          </p>
          <p class="para">
            또한 gcc 컴파일러와 c 파일에 Stack Buffer Overflow 취약점을
            포함시켜, 참가자들이 메모리 관리와 보안 취약점에 대한 이해를 높일 수
            있도록 하였습니다.
          </p>
          <p class="para">
            최종적으로 발견되는 이집트 상형문자(히에로글리프)와 같이 일반적으로
            바로 해독할 수 없는 문자를 포함하여 CTF의 컨셉을 지킴과 동시에, Base
            58과 같은 다양한 인코딩 방식을 활용하여 참가자들이 다양한 해독
            기법을 연습할 수 있도록 하였습니다.
          </p>
        </figure>
      </section>
    </main>
    <main class="ctf-page">
      <header class="ctf-header">
        <h1 class="heading-main">Pyramid 1 단계 SQLi Walkthrough</h1>
      </header>

      <section class="ctf-section">
        <p class="para">IP 확인 후 HTTP로 서비스에 접속한다.</p>

        <figure class="fig">
          <img
            src="images/walkthrough/image001.jpg"
            alt="Pyramid 1 초기 접속 화면"
          />
          <figcaption class="fig-caption">초기 진입 페이지 화면</figcaption>
        </figure>

        <p class="para">
          검색 입력창에 <code class="code-inline">' OR '1'='1</code> 과 같은
          가장 기본적인 SQLi 페이로드를 입력했을 때 전체 행이 반환되는지
          확인한다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image002.jpg"
            alt="기본 SQLi 페이로드 실행 결과"
          />
          <figcaption class="fig-caption">
            기본 SQLi 페이로드 입력 후 전체 레코드가 조회되는 모습
          </figcaption>
        </figure>

        <h2 class="heading-sub">알 수 있는 사실</h2>
        <ul class="bullet-list">
          <li>입력값이 필터링 없이 DB 쿼리에 직접 사용된다.</li>
          <li>
            URL 에서 파라미터 name 값이 그대로 노출되며 GET 방식으로 서버로
            전송된다.
          </li>
          <li>
            화면에는 3개의 칼럼만 표시되지만 실제 쿼리에는 더 많은 컬럼이 존재할
            수 있다.
          </li>
          <li>
            OR, SELECT 등 키워드가 차단되지 않아 SQL Injection 취약점이
            존재한다.
          </li>
        </ul>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">1. 테이블명 추출 SQLi</h2>
        <p class="para">
          UNION 기반 SQL Injection을 이용해 현재 데이터베이스의 테이블 이름을
          수집한다.
        </p>

        <pre class="code-block">
' UNION SELECT 1, group_concat(table_name), 3
  FROM information_schema.tables
 WHERE table_schema = database() --</pre
        >

        <figure class="fig">
          <img src="images/walkthrough/image003.jpg" alt="테이블명 추출 결과" />
          <figcaption class="fig-caption">
            두 번째 컬럼 위치에 테이블 이름들이 출력된다.
          </figcaption>
        </figure>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">2. 칼럼명 추출 SQLi</h2>
        <p class="para">
          식별한 테이블 <code class="code-inline">pharaohs</code> 에 대해 모든
          컬럼명을 조회한다.
        </p>

        <pre class="code-block">
' UNION SELECT 1, group_concat(column_name), 3
  FROM information_schema.columns
 WHERE table_name = 'pharaohs' --</pre
        >

        <figure class="fig">
          <img
            src="images/walkthrough/image004.jpg"
            alt="pharaohs 테이블 컬럼명 추출 결과"
          />
          <figcaption class="fig-caption">
            두 번째 컬럼 위치에 pharaohs 테이블의 모든 컬럼명이 출력된다.
          </figcaption>
        </figure>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">3. secret_info 컬럼에서 최종 힌트 획득</h2>
        <p class="para">
          <code class="code-inline">pharaohs</code> 테이블의
          <code class="code-inline">secret_info</code> 컬럼을 대상으로 조건부
          조회를 수행해 최종 힌트를 얻는다.
        </p>

        <pre class="code-block">
' UNION SELECT 1, 2, secret_info
  FROM pharaohs
 WHERE id = 6 --</pre
        >

        <figure class="fig">
          <img
            src="images/walkthrough/image005.jpg"
            alt="secret_info 컬럼 조회 결과"
          />
          <figcaption class="fig-caption">
            secret_info 컬럼에서 의미 있는 문장이 조회된다.
          </figcaption>
        </figure>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">4. 소스코드 주석과 ROT13 힌트 해석</h2>

        <figure class="fig">
          <img
            src="images/walkthrough/image006.jpg"
            alt="소스 코드 주석에 포함된 긴 문자열"
          />
          <figcaption class="fig-caption">
            페이지 소스 주석에 매우 긴 문자열이 포함되어 있다.
          </figcaption>
        </figure>

        <figure class="fig">
          <img
            src="images/walkthrough/image007.jpg"
            alt="ROT13.com 에서 문자열 디코딩"
          />
          <figcaption class="fig-caption">
            ROT13.com 등 온라인 도구를 이용해 문자열을 디코딩한다.
          </figcaption>
        </figure>

        <p class="para">
          ROT13 디코딩 결과는 “파라오의 암호는 문지기의 열쇠를 위한 것이 아니라,
          펼쳐지는 나일강 지도의 논리를 위해 존재한다. 흐름을 따라 다음 방으로
          나아가라.” 와 같은 의미의 문장이다.
        </p>
        <p class="para">
          이 문구는 SSH 접속 정보가 아니라는 점을 암시하며, 흐름(flow)을 따라 웹
          디렉터리를 이동해야 한다는 메시지를 비유적으로 전달한다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image008.png"
            alt="디렉터리 경로를 암시하는 힌트"
          />
          <figcaption class="fig-caption">
            슬래시(/)와 함께 디렉터리 경로 형태의 문자열이 포함되어 있다.
          </figcaption>
        </figure>

        <p class="para">
          최종 힌트에 슬래시(<code class="code-inline">/</code>)가 포함되어 있어
          디렉터리 경로임을 유추할 수 있고,
          <code class="code-inline"
            >http://pyramidIP/the_architect_of_the_Great_Pyramid</code
          >
          와 같은 URL 로 이동하면 다음 단계로 넘어갈 수 있다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image009.jpg"
            alt="trivia 칼럼 조회 결과"
          />
          <figcaption class="fig-caption">
            trivia 칼럼에는 3000자 분량의 반복 문자열과 수동 SQLi 를 유도하는
            메시지가 포함된다.
          </figcaption>
        </figure>

        <p class="para">
          trivia 칼럼의 내용을 읽어 보면 자동화 도구(sqlmap) 대신 수동 SQL
          Injection 과정을 경험해 보라는 의도가 담겨 있음을 알 수 있다.
        </p>

        <p class="para">
          더 자세한 풀이 과정은 외부 블로그에 정리되어 있으며, 비밀번호는
          <code class="code-inline">cmd</code> 로 안내된다.
        </p>
      </section>

      <header class="ctf-header">
        <h1 class="heading-main">
          Pyramid (2) – Find Split Fragment and Decryption
        </h1>
      </header>

      <section class="ctf-section">
        <h2 class="heading-sub">0. 시나리오 개요</h2>
        <p class="para">
          <code class="code-inline">/the_architect_of_the_Great_Pyramid/</code>
          페이지에 접속하면 세 개의 fragment를 찾아 조합하고, 제공된 스크립트에
          따라 암호를 복호화해야 한다는 힌트가 나온다.
        </p>

        <p class="para">
          접속 URL:
          <a href="http://192.168.16.36/the_architect_of_the_Great_Pyramid/">
            http://192.168.16.36/the_architect_of_the_Great_Pyramid/
          </a>
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image010.jpg"
            alt="the_architect_of_the_Great_Pyramid 초기 화면"
          />
          <figcaption class="fig-caption">
            세 개의 fragment 위치와 조합 방법에 대한 안내가 포함된 초기 페이지
          </figcaption>
        </figure>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">1. Fragment 1 – HTML 소스에서 Xv9A 찾기</h2>

        <p class="para">
          Fragment1 을 찾기 위해 브라우저에서
          <strong>View page source</strong> 로 HTML 소스를 확인한다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image011.png"
            alt="페이지 소스 내 Fragment1"
          />
          <figcaption class="fig-caption">
            페이지 소스의 주석 영역에서
            <code class="code-inline">Xv9A</code> 문자열을 확인
          </figcaption>
        </figure>

        <p class="para">
          HTML 주석을 통해 Fragment1 값인
          <code class="code-inline">Xv9A</code> 를 획득한다.
        </p>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">2. Fragment 2 – script.js 에서 MuS7 확인</h2>

        <p class="para">
          다음으로 Fragment2 를 찾기 위해 자바스크립트 파일에 접근한다.
        </p>

        <p class="para">
          URL:
          <a
            href="http://192.168.16.36/the_architect_of_the_Great_Pyramid/assets/script.js"
          >
            http://192.168.16.36/the_architect_of_the_Great_Pyramid/assets/script.js
          </a>
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image012.png"
            alt="script.js 내부의 Fragment2"
          />
          <figcaption class="fig-caption">
            스크립트 내부에 <code class="code-inline">MuS7</code> 라는 hex 관련
            힌트가 포함되어 있다.
          </figcaption>
        </figure>

        <p class="para">
          스크립트 내용에서 Fragment2 값인
          <code class="code-inline">MuS7</code> 을 확인한다.
        </p>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">
          3. Fragment 3 – hint.png 메타데이터에서 z9Qp 추출
        </h2>

        <p class="para">
          Fragment3 을 찾기 위해 이미지 리소스
          <code class="code-inline">hint.png</code> 를 직접 요청한다.
        </p>

        <p class="para">
          URL:
          <a
            href="http://192.168.16.36/the_architect_of_the_Great_Pyramid/assets/hint.png"
          >
            http://192.168.16.36/the_architect_of_the_Great_Pyramid/assets/hint.png
          </a>
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image013.jpg"
            alt="hint.png 이미지 자체는 비어 있는 것처럼 보임"
          />
          <figcaption class="fig-caption">
            이미지를 보면 아무 내용이 없어 보이므로 메타데이터를 확인해야 한다.
          </figcaption>
        </figure>

        <p class="para">
          이미지를 <code class="code-inline">kali</code> 로 다운로드한 뒤,
          <code class="code-inline">exiftool</code> 과 같은 메타데이터 분석
          도구를 사용해 숨겨진 정보를 확인한다.
        </p>

        <p class="para">
          첫 페이지에서 이미 "metadata 를 확인하라" 는 힌트를 받았으며, 대표적인
          툴로
          <code class="code-inline">exiftool</code> 을 사용할 수 있다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image014.jpg"
            alt="exiftool 로 확인한 hint.png 메타데이터"
          />
          <figcaption class="fig-caption">
            Comment 필드에 의심스러운 문자열
            <code class="code-inline">z9Qp</code> 가 저장되어 있다.
          </figcaption>
        </figure>

        <p class="para">
          Comment 항목에서 Fragment3 값인
          <code class="code-inline">z9Qp</code> 를 획득한다.
        </p>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">4. Fragment 결합 및 concat 값 구성</h2>

        <p class="para">
          이제 얻어 둔 세 개의 fragment
          <code class="code-inline">Xv9A</code>,
          <code class="code-inline">MuS7</code>,
          <code class="code-inline">z9Qp</code> 를 지정된 순서대로 이어붙여
          <code class="code-inline">concat</code> 값을 만든다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image015.png"
            alt="세 fragment 를 결합한 concat 예시"
          />
          <figcaption class="fig-caption">
            세 fragment 를 합쳐 하나의 문자열로 구성하는 모습
          </figcaption>
        </figure>

        <p class="para">
          최종적으로
          <code class="code-inline">concat="Xv9AMuS7z9Qp"</code>
          형태의 값을 사용하게 된다.
        </p>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">5. 페이지 하단 스크립트 – 키 파생 로직</h2>

        <p class="para">
          <code class="code-inline">the_architect_of_the_Great_Pyramid</code>
          페이지 하단에는 암호화/복호화와 관련된 쉘 스크립트 조각이 적혀 있다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image016.jpg"
            alt="페이지 하단에 노출된 key 파생 스크립트"
          />
          <figcaption class="fig-caption">
            concat 값을 기반으로 SHA-256 해시를 계산하고 앞 16바이트를 key 로
            사용하는 스크립트
          </figcaption>
        </figure>

        <pre class="code-block">
keyhex=$(echo -n "$concat" \
  | openssl dgst -sha256 -binary \
  | xxd -p -c 256 \
  | cut -c1-32)

echo "Derived key (hex,16 bytes): $keyhex"</pre
        >

        <p class="para">
          이 스크립트는 <code class="code-inline">concat</code> 문자열에 대해
          SHA-256 해시를 계산하고, 그 결과에서 앞 16바이트(32 hex 문자)를 잘라
          <code class="code-inline">keyhex</code> 라는 AES 키로 사용한다.
        </p>

        <p class="para">
          스크립트를 실행하면 파생된 hex 형태의 키를 확인할 수 있다.
        </p>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">6. 암호문 base64 값 확보</h2>

        <p class="para">
          페이지에는 별도로 base64 인코딩된 암호문 문자열이 주어지며, 이를
          <code class="code-inline">b64</code> 변수로 사용한다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image017.png"
            alt="페이지에서 제공되는 base64 암호문"
          />
          <figcaption class="fig-caption">
            암호문을 base64 형태로 제공하는 부분
          </figcaption>
        </figure>

        <p class="para">
          이 값은 이후 복호화 절차에서
          <code class="code-inline">echo -n "$b64" | base64 -d</code>
          형태로 디코딩에 사용된다.
        </p>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">
          7. 복호화 절차 – payload 분석과 AES-128-CBC 복호화
        </h2>

        <h3 class="heading-sub">7‑1. base64 디코딩</h3>

        <figure class="fig">
          <img
            src="images/walkthrough/image018.jpg"
            alt="base64 디코딩 스크립트 일부"
          />
          <figcaption class="fig-caption">
            base64 를 디코드하여 /tmp/payload.bin 으로 저장하는 부분
          </figcaption>
        </figure>

        <pre class="code-block">
echo -n "$b64" | base64 -d > /tmp/payload.bin
ls -l /tmp/payload.bin</pre
        >

        <p class="para">
          <code class="code-inline">$b64</code> 에 저장된 헤더 없는 base64
          문자열을 디코드해 바이너리 파일
          <code class="code-inline">/tmp/payload.bin</code> 으로 저장하고,
          파일이 제대로 생성되었는지 크기와 권한을 확인한다.
        </p>

        <h3 class="heading-sub">7‑2. IV 값 추출</h3>

        <figure class="fig">
          <img
            src="images/walkthrough/image019.jpg"
            alt="payload 앞부분 헥스 덤프 예시"
          />
          <figcaption class="fig-caption">
            payload 앞부분을 xxd 로 확인하여 IV 위치를 파악
          </figcaption>
        </figure>

        <pre class="code-block">
xxd -g 1 -l 32 /tmp/payload.bin | sed -n '1,3p'
ivhex=$(xxd -p -l 16 /tmp/payload.bin | tr -d '\n')</pre
        >

        <p class="para">
          <code class="code-inline">xxd</code> 로 payload 앞 32바이트를
          헥스+ASCII 형식으로 확인한 뒤, 처음 16바이트를 IV 로 사용하기 위해
          <code class="code-inline">ivhex</code> 변수에 연속된 hex 문자열 형태로
          저장한다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image020.png"
            alt="ivhex 추출 결과 예시"
          />
          <figcaption class="fig-caption">
            ivhex 변수에 저장된 16바이트 길이의 IV 값
          </figcaption>
        </figure>

        <h3 class="heading-sub">7‑3. 암호문(cipher) 추출 및 크기 확인</h3>

        <figure class="fig">
          <img
            src="images/walkthrough/image021.jpg"
            alt="cipher.bin 추출 및 크기 확인"
          />
          <figcaption class="fig-caption">
            IV 이후 영역을 잘라 cipher.bin 으로 저장하는 과정
          </figcaption>
        </figure>

        <pre class="code-block">
dd if=/tmp/payload.bin of=/tmp/cipher.bin bs=1 skip=16 status=none
stat -c "cipher.bin size: %s bytes" /tmp/cipher.bin</pre
        >

        <p class="para">
          payload 의 앞 16바이트(IV)를 건너뛰고 나머지 내용을
          <code class="code-inline">/tmp/cipher.bin</code> 으로 복사해 순수
          암호문을 분리하고, <code class="code-inline">stat</code> 명령으로
          크기가 기대값과 일치하는지 확인한다.
        </p>

        <h3 class="heading-sub">7‑4. AES‑128‑CBC 복호화</h3>

        <figure class="fig">
          <img
            src="images/walkthrough/image022.jpg"
            alt="openssl enc 복호화 명령"
          />
          <figcaption class="fig-caption">
            openssl enc 를 사용한 AES‑128‑CBC 복호화 명령
          </figcaption>
        </figure>

        <pre class="code-block">
openssl enc -d -aes-128-cbc \
  -in /tmp/cipher.bin \
  -K "$keyhex" \
  -iv "$ivhex" \
  -out /tmp/plain.txt 2>/tmp/openssl.err || true</pre
        >

        <p class="para">
          앞에서 얻은 <code class="code-inline">keyhex</code> 와
          <code class="code-inline">ivhex</code> 를 사용해
          <code class="code-inline">openssl enc -d -aes-128-cbc</code> 로
          <code class="code-inline">cipher.bin</code> 을 복호화하고 결과를
          <code class="code-inline">/tmp/plain.txt</code> 에 저장한다. 오류
          메시지는 <code class="code-inline">/tmp/openssl.err</code> 로
          리다이렉트한다.
        </p>

        <p class="para">
          <code class="code-inline">|| true</code> 를 붙여, openssl 명령이
          실패하더라도 전체 스크립트가 중단되지 않고 계속 진행되도록 처리한다.
        </p>

        <h3 class="heading-sub">7‑5. 평문(PW) 확인</h3>

        <figure class="fig">
          <img
            src="images/walkthrough/image023.png"
            alt="복호화된 평문 출력 스크립트"
          />
          <figcaption class="fig-caption">
            복호화된 평문을 출력하는 부분
          </figcaption>
        </figure>

        <pre class="code-block">
echo "Decrypted (text):"
cat /tmp/plain.txt || true</pre
        >

        <figure class="fig">
          <img
            src="images/walkthrough/image024.png"
            alt="luckforyournext_!21! 결과"
          />
          <figcaption class="fig-caption">
            최종 평문에서
            <code class="code-inline">luckforyournext_!21!</code> 문자열을 확인
          </figcaption>
        </figure>

        <p class="para">
          복호화 결과 평문에서
          <code class="code-inline">luckforyournext_!21!</code>
          라는 문자열을 얻을 수 있으며, 이는 다음 단계로 진입할 때 사용하는
          패스워드이다.
        </p>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">8. 다음 단계로 이동하는 힌트</h2>

        <figure class="fig">
          <img
            src="images/walkthrough/image025.jpg"
            alt="다음 페이지에 대한 UI 힌트"
          />
          <figcaption class="fig-caption">
            페이지 우측 하단 특정 영역에 마우스를 올리면 커서 모양이 바뀌며,
            클릭 시 다음 단계 힌트가 나타난다.
          </figcaption>
        </figure>

        <ul class="bullet-list">
          <li>우측 하단을 잘 살펴보면 커서 모양이 바뀌는 작은 영역이 있다.</li>
          <li>
            그 지점을 클릭하면 다음 페이지로 이동하기 위한 추가 힌트가 표시된다.
          </li>
        </ul>

        <p class="para">
          이렇게 얻은 비밀번호와 UI 상의 힌트를 조합해, 이후 웹 게임 및 파일
          업로드 단계로 진입할 수 있다.
        </p>
      </section>

      <header class="ctf-header">
        <h1 class="heading-main">
          Pyramid (3) – Web Game & File Upload Exploitation
        </h1>
      </header>

      <section class="ctf-section">
        <h2 class="heading-sub">1. game.php 진입 – 이전 단계 비밀번호 활용</h2>

        <p class="para">
          이전 단계에서 모달 창을 통해 다음 페이지가
          <code class="code-inline">game.php</code> 라는 힌트를 얻었고, 복호화
          과정을 완료하면 비밀번호
          <code class="code-inline">luckforyournext_!21!</code> 가 나온다. 이
          값을 <code class="code-inline">game.php</code> 페이지 진입 시
          비밀번호로 입력하면 된다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image026.jpg"
            alt="game.php 진입 비밀번호 입력 화면"
          />
          <figcaption class="fig-caption">
            luckforyournext_!21! 을 입력해 game.php 로 진입
          </figcaption>
        </figure>

        <figure class="fig">
          <img src="images/walkthrough/image027.jpg" alt="game.php 메인 화면" />
          <figcaption class="fig-caption">
            비밀번호 인증 후 표시되는 game.php 메인 페이지
          </figcaption>
        </figure>

        <p class="para">
          정상적으로 인증되면 위와 같이 여러 개의 이미지를 포함한
          <code class="code-inline">game.php</code> 페이지가 열린다.
        </p>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">2. mirro.php – 미로 탈출과 ROT13 플래그</h2>

        <p class="para">
          game.php 첫 번째 이미지를 클릭하면
          <code class="code-inline">mirro.php</code> 페이지가 열린다. 이
          페이지에서 미로를 탈출하면 플래그 형태의 문자열
          <code class="code-inline">uvrebtylcuvp</code> 를 획득할 수 있다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image028.jpg"
            alt="mirro.php 미로 화면 1"
          />
        </figure>

        <figure class="fig">
          <img
            src="images/walkthrough/image029.jpg"
            alt="mirro.php 미로 화면 2"
          />
          <figcaption class="fig-caption">
            미로를 모두 통과하면 ROT13 으로 인코딩된 플래그가 노출된다.
          </figcaption>
        </figure>

        <p class="para">
          문자열 <code class="code-inline">uvrebtylcuvp</code> 에 ROT13 을
          적용하면 <code class="code-inline">hieroglyphic</code> 이라는 단어가
          나오며, “이집트 상형문자”를 의미하는 동시에
          <code class="code-inline">chamber.php</code> 페이지 비밀번호 힌트
          역할을 한다.
        </p>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">
          3. image.php – chamber.php 로 이어지는 모달 힌트
        </h2>

        <p class="para">
          game.php 에서 두 번째 이미지를 클릭하면
          <code class="code-inline">image.php</code> 페이지가 열린다.
        </p>

        <p class="para">
          화면 곳곳을 클릭해 보면 특정 영역에서 모달 창이 뜨는데, 이 모달 안에
          다음 페이지 이름이 <code class="code-inline">chamber</code> 라는
          힌트가 포함되어 있다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image030.jpg"
            alt="image.php 전체 화면"
          />
          <figcaption class="fig-caption">
            image.php 화면의 특정 지점을 클릭하면 모달 창이 노출된다.
          </figcaption>
        </figure>

        <figure class="fig">
          <img src="images/walkthrough/image031.png" alt="모달 트리거 영역" />
          <figcaption class="fig-caption">
            이 영역을 클릭하면 다음 페이지 이름 chamber 에 대한 힌트가 나타난다.
          </figcaption>
        </figure>

        <figure class="fig">
          <img
            src="images/walkthrough/image032.jpg"
            alt="chamber 페이지 이름 힌트 모달"
          />
          <figcaption class="fig-caption">
            모달 창에서 다음 페이지 이름이 chamber 라는 것을 확인
          </figcaption>
        </figure>

        <p class="para">
          이전 단계에서 페이지들이 모두
          <code class="code-inline">.php</code> 확장자를 사용했던 점을 고려하면,
          자연스럽게 <code class="code-inline">chamber.php</code> 로 이동할 수
          있다. 이때 앞에서 얻은 비밀번호
          <code class="code-inline">hieroglyphic</code> 을 입력해 인증을
          통과한다.
        </p>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">
          4. chamber.php – 이집트 상형문자 해독과 Tomb.php
        </h2>

        <p class="para">
          <code class="code-inline">chamber.php</code> 에 접속하여 비밀번호
          <code class="code-inline">hieroglyphic</code> 을 입력하면, 화면에
          이집트 상형문자로 된 암호문이 나타난다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image033.jpg"
            alt="chamber.php 상형문자 화면"
          />
          <figcaption class="fig-caption">
            이집트 상형문자로만 구성된 문구를 해독해야 한다.
          </figcaption>
        </figure>

        <p class="para">
          인터넷에서 이집트 상형문자 알파벳 표를 찾아 매핑하면
          <code class="code-inline">artifact</code> 라는 플래그를 얻을 수 있고,
          이것이 다음 Tomb 단계의 비밀번호가 된다.
        </p>

        <p class="para">
          또한 화면 오른쪽 아래 특정 부분을 클릭하면 모달 창이 나타나며, 다음 방
          이름이 <code class="code-inline">Tomb</code> 라는 힌트를 제공한다.
          이를 통해 다음 페이지가 <code class="code-inline">Tomb.php</code> 임을
          유추할 수 있다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image034.png"
            alt="Tomb 힌트가 열리는 클릭 영역"
          />
        </figure>

        <figure class="fig">
          <img
            src="images/walkthrough/image035.jpg"
            alt="다음 페이지 이름 Tomb 를 알려주는 모달"
          />
          <figcaption class="fig-caption">
            모달에서 다음 페이지 이름 Tomb 를 확인할 수 있다.
          </figcaption>
        </figure>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">5. Tomb.php – 파일 업로드 취약점 개요</h2>

        <p class="para">
          <code class="code-inline">Tomb.php</code> 에 접속해 앞에서 얻은
          <code class="code-inline">artifact</code> 값을 비밀번호로 입력하면,
          파일 업로드 기능이 있는 페이지가 나타난다.
        </p>

        <p class="para">
          그러나 일반 사용자가 이 페이지에서 직접 업로드를 시도하면 권한
          부족으로 인해 업로드에 실패한다. 대신, 서버 측의
          <code class="code-inline">upload.php</code> 는 세션·권한 체크를 하지
          않기 때문에 누구나 직접 <strong>POST 요청</strong> 을 보내 파일을
          업로드할 수 있는 취약점이 존재한다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image036.jpg"
            alt="Tomb.php 파일 업로드 페이지"
          />
          <figcaption class="fig-caption">
            UI 상에서는 업로드가 차단되어 있지만, upload.php 는 별도 검증 없이
            파일을 처리한다.
          </figcaption>
        </figure>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">6. /uploads 디렉터리와 shell 업로드</h2>

        <p class="para">
          공격자는 로컬에서 임의의
          <code class="code-inline">test.php</code> 파일을 만든 뒤,
          <code class="code-inline">curl</code> 을 사용해
          <code class="code-inline">upload.php</code> 로 직접 파일을 전송한다.
          업로드된 파일은 웹 서버의
          <code class="code-inline">/uploads</code> 디렉터리에 저장된다.
        </p>

        <p class="para">
          <code class="code-inline">/uploads</code> 경로는
          <code class="code-inline">dirb http://192.168.16.54</code> 와 같은
          디렉터리 브루트포싱 도구를 사용해 찾을 수 있다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image037.png"
            alt="/uploads 디렉터리를 찾는 예시"
          />
          <figcaption class="fig-caption">
            디렉터리 브루트포싱으로 /uploads 경로를 식별
          </figcaption>
        </figure>

        <p class="para"><strong>1) test.php 작성</strong></p>

        <figure class="fig">
          <img
            src="images/walkthrough/image038.jpg"
            alt="test.php 예시 파일 작성 화면"
          />
          <figcaption class="fig-caption">
            간단한 PHP 코드로 구성된 test.php 생성
          </figcaption>
        </figure>

        <p class="para">
          <strong>2) curl 을 이용해 upload.php 로 업로드</strong>
        </p>

        <pre class="code-block">
curl -v -F "file=@./test.php;filename=shell.php" \
  http://192.168.16.15/upload.php</pre
        >

        <p class="para"><strong>3) /uploads 경로 접속</strong></p>

        <p class="para">
          브라우저에서 <code class="code-inline">/uploads</code> 디렉터리에
          접근하면, 방금 업로드한
          <code class="code-inline">shell.php</code> 파일이 생성된 것을 확인할
          수 있다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image039.jpg"
            alt="/uploads 디렉터리 내 shell.php 확인"
          />
          <figcaption class="fig-caption">
            업로드된 shell.php 파일이 /uploads 디렉터리에 존재하는 모습
          </figcaption>
        </figure>

        <p class="para">
          이후 <code class="code-inline">shell.php</code> 에 접속하면 서버
          측에서 플래그가 출력되며, 이 플래그는 다음 단계에서 SSH 사용자
          비밀번호로 사용된다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image040.png"
            alt="shell.php 에서 플래그 출력 화면"
          />
          <figcaption class="fig-caption">
            shell.php 실행 결과로 노출되는 플래그 문자열
          </figcaption>
        </figure>
      </section>

      <header class="ctf-header">
        <h1 class="heading-main">Pyramid 4 단계 Walk-Through</h1>
      </header>

      <section class="ctf-section">
        <h2 class="heading-sub">1. SSH 접속 – khufu 계정</h2>

        <p class="para">
          3단계에서 획득한 비밀번호를 이용해 SSH 접속을 시도한다. 이 단계에서는
          <code class="code-inline">khufu</code> 계정으로 서버에 로그인한다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image041.png"
            alt="khufu 계정으로 SSH 접속 화면"
          />
          <figcaption class="fig-caption">
            SSH 접속에 사용된 계정 정보: Username
            <code class="code-inline">khufu</code>, Password
            <code class="code-inline">747574616e6b68616d756e</code>
          </figcaption>
        </figure>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">2. 홈 디렉터리 구조 파악</h2>

        <p class="para">
          로그인 후 <code class="code-inline">ls -la</code> 명령어로
          <code class="code-inline">/home/khufu</code> 디렉터리 구조를 확인한다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image042.png"
            alt="/home/khufu 디렉터리 구조"
          />
          <figcaption class="fig-caption">
            <code class="code-inline">papyrus</code>,
            <code class="code-inline">room</code>,
            <code class="code-inline">rosetta_stone</code> 파일·디렉터리가
            존재한다.
          </figcaption>
        </figure>

        <p class="para">
          먼저 <code class="code-inline">papyrus</code> 파일 내용을 확인하면
          피라미드와 마법에 대한 서술이 등장하며, 이후 퍼즐 풀이 방향을
          암시한다.
        </p>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">
          3. /home/khufu/room – 네 개의 제물(offering)
        </h2>

        <p class="para">
          <code class="code-inline">/home/khufu/room</code> 하위 구조를 살펴보면
          여러 디렉터리와 파일이 존재한다. 특히
          <code class="code-inline">1</code>,
          <code class="code-inline">2</code>,
          <code class="code-inline">3</code>,
          <code class="code-inline">4</code> 디렉터리가 중요하다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image043.png"
            alt="/home/khufu/room 디렉터리 구조"
          />
          <figcaption class="fig-caption">
            room 디렉터리 내에 1~4 디렉터리와 여러 파일(book_pen, dedicate,
            pray, papyrus 등)이 있다.
          </figcaption>
        </figure>

        <figure class="fig">
          <img
            src="images/walkthrough/image044.png"
            alt="room/1 디렉터리 내용"
          />
        </figure>

        <figure class="fig">
          <img
            src="images/walkthrough/image045.png"
            alt="room/2, room/4 디렉터리 내용"
          />
          <figcaption class="fig-caption">
            /1, /2, /4 디렉터리에는 공통 이름의 파일
            <code class="code-inline">offering</code> 이 존재하며, 잘려 있는 C
            코드 조각처럼 보인다.
          </figcaption>
        </figure>

        <p class="para">
          /3 디렉터리에는 <code class="code-inline">offering</code> 파일이
          존재하지 않으며, 이후 퍼즐에서 이 누락된 제물을 생성하는 것이 목표가
          된다.
        </p>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">4. room/papyrus – 힌트 텍스트 분석</h2>

        <figure class="fig">
          <img
            src="images/walkthrough/image046.png"
            alt="room/papyrus 파일 내용"
          />
          <figcaption class="fig-caption">
            room/papyrus 파일은 네 개의 제물(offering)과 봉헌(dedicating),
            prayer 에 대한 힌트를 준다.
          </figcaption>
        </figure>

        <p class="para">
          room/papyrus 에 따르면, 네 개의 제물이 모두 모이면
          <code class="code-inline">pray</code> 를 통해 소원을 빌 수 있다. 또한
          봉헌(dedicating)은 신에게 기도하는 가장 좋은 방법이며, offering 을
          작성하기 위해서는 <code class="code-inline">book</code> 과
          <code class="code-inline">pen</code> 이 필요하다는 내용을 포함한다.
        </p>

        <p class="para">
          이를 통해 <code class="code-inline">room/book_pen</code> 파일이
          사용자의 입력을 받아 <code class="code-inline">offering</code> 내용을
          구성하고, <code class="code-inline">dedicate</code> 와
          <code class="code-inline">pray</code> 가 그 흐름을 이어가는 구조일
          것이라 추론할 수 있다.
        </p>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">5. offering C 코드 조합과 BoF 취약점</h2>

        <p class="para">
          room/1, room/2, room/4 의
          <code class="code-inline">offering</code> 파일을 하나로 합쳐보면
          아래와 같은 C 코드가 된다.
        </p>

        <pre class="code-block">
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

int main() {
  char code[] = "touch /home/khufu/.&lt;특수문자열&gt;_&lt;특수문자열&gt;";
  int core = system(code);
  char guard[1];
  char altar[7]; // 2

  strcpy(altar, offering);

  return 0;
}</pre
        >

        <p class="para">
          코드 상에서 <code class="code-inline">altar</code> 배열은 크기가 7로
          고정되어 있지만,
          <code class="code-inline">strcpy(altar, offering);</code> 호출에는
          길이 검증이 없으므로 입력 값이 크면 버퍼 오버플로우가 발생할 수 있다.
        </p>

        <p class="para">
          이 취약점을 이용해 <code class="code-inline">offering</code> 변수에
          충분히 긴 문자열을 집어넣고, 이후 흐름에서 이를 실행시키는 방식으로
          익스플로잇을 진행한다.
        </p>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">
          6. book_pen, dedicate – 누락된 3번째 제물 생성
        </h2>

        <h3 class="heading-sub">6‑1. book_pen 에 공격용 입력 작성</h3>

        <figure class="fig">
          <img
            src="images/walkthrough/image047.png"
            alt="book_pen 파일에 긴 offering 값 작성"
          />
          <figcaption class="fig-caption">
            book_pen 파일에 altar 크기를 넘어서는 길이의 문자열을 기록한다.
          </figcaption>
        </figure>

        <p class="para">
          <code class="code-inline">/home/khufu/room/book_pen</code> 파일에
          <code class="code-inline">offering</code> 변수로 쓰일 긴 문자열을
          기입해, 주변 메모리 영역까지 침범할 수 있도록 구성한다. 스크린샷에
          보이는 값은 예시이며, 실제 공격에 맞게 조정할 수 있다.
        </p>

        <h3 class="heading-sub">6‑2. dedicate 실행 후 room/3/offering 생성</h3>

        <figure class="fig">
          <img
            src="images/walkthrough/image048.png"
            alt="dedicate 실행 및 room/3/offering 생성 확인"
          />
          <figcaption class="fig-caption">
            dedicate 실행 후 room/3 디렉터리에 offering 파일이 새로 생성된다.
          </figcaption>
        </figure>

        <p class="para">
          <code class="code-inline">/home/khufu/room/dedicate</code> 파일을
          실행하면, 이전에 없던
          <code class="code-inline">room/3/offering</code> 이 생성되고, 내용에는
          <code class="code-inline">book_pen</code> 에 입력했던 문자열이 그대로
          들어간 것을 확인할 수 있다.
        </p>

        <p class="para">
          이제 room/1~4 의 네 개 offering 이 모두 준비되었으므로,
          <code class="code-inline">papyrus</code> 힌트에 따라
          <code class="code-inline">pray</code> 를 실행해 제물이 모두 모이도록
          한다.
        </p>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">7. pray – offering 결합과 magi.c 생성</h2>

        <p class="para">
          <code class="code-inline">/home/khufu/room/pray</code> 파일을 실행하면
          분할된 네 개의 offering 파일을 하나로 합쳐 새로운 C 소스 파일을
          생성하려는 동작이 수행된다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image049.png"
            alt="pray 실행 결과 로그"
          />
          <figcaption class="fig-caption">
            pray 실행 시 5번째 인자 관련 메시지를 통해 최소 5개의 인자가
            사용됨을 유추할 수 있다.
          </figcaption>
        </figure>

        <p class="para">
          Linux 에서는
          <code class="code-inline">cat file1 file2 &gt;&gt; file3</code> 처럼
          여러 파일을 이어붙여 하나의 파일을 만드는 것이 가능하다. pray 는 네
          개의 offering 파일을 하나의 C 코드로 묶는 역할을 하는 것으로 보이며,
          결과 파일 이름은 <code class="code-inline">.c</code> 확장자를 가져야
          한다.
        </p>

        <p class="para">
          <code class="code-inline">/home/khufu/papyrus</code> 내용을 다시 보면
          “magi…c 가 필요하다” 라는 문장이 등장하므로,
          <code class="code-inline">magi.c</code> 라는 이름으로 코드를 생성하는
          흐름을 추측할 수 있다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image050.png"
            alt="papyrus 의 magi 관련 구문"
          />
          <figcaption class="fig-caption">
            papyrus 에서 magi/magic 관련 힌트를 다시 확인
          </figcaption>
        </figure>

        <figure class="fig">
          <img
            src="images/walkthrough/image051.jpg"
            alt="pray 실행 후 magi.c 생성"
          />
          <figcaption class="fig-caption">
            pray 실행이 성공적으로 끝나면 magi.c 가 생성되고, 네 개의 offering
            코드가 합쳐진 완전한 C 코드가 된다.
          </figcaption>
        </figure>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">8. magic – 주기적 실행과 숨겨진 파일</h2>

        <p class="para">
          <code class="code-inline">/home/khufu/magic</code> 파일을 다시 열어
          보면 마지막 줄에 “magic 은 1분마다 일어난다” 는 설명이 있다.
        </p>

        <figure class="fig">
          <img src="images/walkthrough/image052.png" alt="magic 파일 내용" />
          <figcaption class="fig-caption">
            magi.c 가 존재할 경우 1분마다 magic 이라는 실행 파일이 생성되는
            구조를 암시한다.
          </figcaption>
        </figure>

        <p class="para">
          실제로 <code class="code-inline">/home/khufu</code> 디렉터리를 다시
          확인해 보면, 이전에 없던 <code class="code-inline">magic</code> 파일이
          새로 생긴 것을 볼 수 있고, magi.c 가 존재할 때마다 일정 주기로 해당
          바이너리가 생성된다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image053.png"
            alt="/home/khufu 에 magic 파일 생성"
          />
        </figure>

        <figure class="fig">
          <img
            src="images/walkthrough/image054.png"
            alt="magic 실행 후 숨겨진 파일 생성"
          />
          <figcaption class="fig-caption">
            magic 실행 시 특수 문자로 된 숨겨진 파일이 생성된다.
          </figcaption>
        </figure>

        <p class="para">
          <code class="code-inline">./magic</code> 을 실행하면 특수 문자로
          구성된 파일 이름이 출력되며, 해당 파일을 읽을 수 있는 권한이 있으므로
          내용을 확인해 본다. 파일 이름은 직접 타이핑하기 어렵기 때문에,
          터미널에서 복사·붙여넣기를 사용하는 것이 편리하다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image055.png"
            alt="숨겨진 파일 내용 일부"
          />
          <figcaption class="fig-caption">
            특수 문자로 구성된 힌트 문자열과 “=&gt; (...) =&gt; 58” 이라는 추가
            힌트가 포함되어 있다.
          </figcaption>
        </figure>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">9. Hieroglyphs 디코딩과 Base58 인코딩</h2>

        <p class="para">
          숨겨진 파일과 이전 단계에서 계속 등장하던 상형문자는 ‘Hieroglyphs’
          라고 부르며, 온라인 도구를 활용해 영문 문자열로 디코딩할 수 있다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image056.jpg"
            alt="Hieroglyphs 디코딩 도구 사용"
          />
          <figcaption class="fig-caption">
            Hieroglyphs 디코더를 사용해 상형문자 문자열을 영문으로 변환
          </figcaption>
        </figure>

        <p class="para">
          디코딩 결과 <code class="code-inline">xgdmklzbthnqfpryAswi</code> 라는
          문자열을 얻을 수 있다. 하지만 힌트에는 “(...) =&gt; 58” 이라고 되어
          있으므로, 추가로 Base58 인코딩을 적용해야 한다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image057.jpg"
            alt="디코딩 결과 xgdmklzbthnqfpryAswi"
          />
          <figcaption class="fig-caption">
            Hieroglyphs 를 디코딩해 얻은 문자열 xgdmklzbthnqfpryAswi
          </figcaption>
        </figure>

        <p class="para">
          CyberChef 등 도구에서 Base58 인코딩을 수행하면
          <code class="code-inline">2gHsQQTDGYNerJuyFFGeUkFEVDj6</code> 라는
          값을 얻을 수 있다. 이 값이 다음 SSH 계정 비밀번호로 사용된다.
        </p>

        <figure class="fig">
          <img src="images/walkthrough/image058.jpg" alt="Base58 인코딩 결과" />
          <figcaption class="fig-caption">
            Base58 인코딩 결과:
            <code class="code-inline">2gHsQQTDGYNerJuyFFGeUkFEVDj6</code>
          </figcaption>
        </figure>
      </section>

      <section class="ctf-section">
        <h2 class="heading-sub">10. 최종 플래그 – tutankhamun 계정</h2>

        <p class="para">
          최종적으로 <code class="code-inline">tutankhamun</code> 계정에 SSH
          접속을 시도한다. 비밀번호로는 방금 구한 Base58 인코딩 문자열
          <code class="code-inline">2gHsQQTDGYNerJuyFFGeUkFEVDj6</code> 를
          사용한다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image059.png"
            alt="tutankhamun 계정 SSH 접속 성공"
          />
          <figcaption class="fig-caption">
            Tutankhamun 계정으로 성공적으로 접속한 화면
          </figcaption>
        </figure>

        <p class="para">
          접속 후 루트 디렉터리로 이동하면
          <code class="code-inline">flag</code> 파일을 발견할 수 있고, 이 파일
          내용을 출력하면 Pyramid CTF 의 최종 플래그를 획득하게 된다.
        </p>

        <figure class="fig">
          <img
            src="images/walkthrough/image060.png"
            alt="root 디렉터리의 flag 파일"
          />
          <figcaption class="fig-caption">
            root 디렉터리에서 발견한 final flag 파일
          </figcaption>
        </figure>

        <figure class="fig">
          <img src="images/walkthrough/image061.png" alt="flag 출력" />
          <figcaption class="fig-caption">
            최종 flag를 찾으며 CTF 풀이가 끝나게 된다.
          </figcaption>
        </figure>
      </section>
    </main>
    <main class="end-notes">
      <header class="ctf-header">
        <h1 class="heading-main">후기</h1>
      </header>
      <section class="ctf-section">
        <h3>느낀점</h3>
        <p class="para">
          본 문서에서는 Pyramid CTF의 주요 단계들을 상세히 살펴보았습니다. 각
          단계마다 요구되는 기술과 사고 방식을 이해하는 것이 중요하며, 이를 통해
          유사한 CTF 문제에 대한 접근 방법을 익힐 수 있습니다.
        </p>

        <p class="para">
          이번 CTF 머신 제작을 통해 단순한 문제 풀이를 넘어, 실제 보안 취약점
          분석과 익스플로잇 개발에 필요한 실전 감각을 키우는 데 큰 도움이
          되었습니다. 이런 경험을 바탕으로 앞으로도 다양한 CTF에 참여하여 경험을
          쌓고, 최신 보안 트렌드와 기술을 습득해 나가길 바랍니다.
        </p>
      </section>
      <h3>성장한점</h3>
      <ol>
        <li>버퍼 오버플로우 취약점에 대한 이해와 대응 방법 습득</li>
        <li>파일 업로드 취약점 분석 및 익스플로잇 기법 학습</li>
        <li>암호화 및 인코딩 기법에 대한 실전 적용 경험</li>
        <li>SetUID 파일의 보안적 취약점과 대응 방법 이해</li>
      </ol>
    </main>
    <script src="tabs.js"></script>
  </body>
</html>
